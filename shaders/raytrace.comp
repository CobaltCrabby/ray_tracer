#version 450
// Rachit was here :)

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct CameraInfo {
    mat4 cameraRotation;
    vec3 pos;
    float nearPlane;
    float aspectRatio;
    float fov;
};

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct Material {
    vec3 albedo;
    vec3 emissionColor;
    float emissionStrength;
    float reflectance;
};

struct Sphere {
    vec3 position;
    float radius;
    uint materialIndex;
};

struct Triangle {
    uint indices[3];
    uint materialIndex;
};

struct HitInfo {
    bool didHit;
    float dst;
    uint materialIndex;
    vec3 hitPoint;
    vec3 normal;
};

struct EnvironmentData {
    vec3 horizonColor;
    vec3 zenithColor;
    vec3 groundColor;
    float sunFocus;
    float sunIntensity;
};

struct RayTracerData {
    bool progressive;
    uint raysPerPixel;
    uint bounceLimit;
    uint sphereCount;
    //uint triangleCount;
};

layout (binding = 0, rgba8) uniform image2D outImage;

layout (std140, binding = 1) readonly buffer SphereBuffer {
    Sphere spheres[];
};

layout (std140, binding = 2) readonly buffer MaterialBuffer {
    Material materials[];
};

// layout (std140, binding = 3) readonly buffer TrianglePositionBuffer {
//     vec3 trianglePoints[];
// };

// layout (std140, binding = 4) readonly buffer TriangleBuffer {
//     Triangle triangles[];
// };

layout (push_constant) uniform constants {
    CameraInfo camInfo;
    EnvironmentData environment;
    RayTracerData rayTracerParams;
    vec3 lightDir;
    //uint sphereCount;
    uint frameCount;
} PushConstants;

//https://www.shadertoy.com/view/4ssXzX
float random(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result / 4294967295.f;
}

float randomNormal(inout uint state) {
    float theta = 2 * 3.141592 * random(state);
    float rho = sqrt(-2 * log(random(state)));
    return rho * cos(theta);
}

vec3 randomDirection(inout uint state) {
    vec3 randomDir = vec3(randomNormal(state), randomNormal(state), randomNormal(state));
    randomDir = normalize(randomDir);
    return randomDir;
}

HitInfo sphereIntersection(Sphere sphere, Ray ray) {
    HitInfo hitInfo;
    hitInfo.didHit = false;

    vec3 oc = ray.origin - sphere.position;
    float a = dot(ray.dir, ray.dir);
    float b = 2 * dot(oc, ray.dir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0) {
        float dst = (-b - sqrt(discriminant)) / (2 * a);
        if (dst >= 0) {
            hitInfo.didHit = true;
            hitInfo.dst = dst;
            hitInfo.hitPoint = ray.origin + ray.dir * dst;
            hitInfo.normal = normalize(hitInfo.hitPoint - sphere.position);
            hitInfo.materialIndex = sphere.materialIndex;
        }
    }
    return hitInfo;
}

//https://iquilezles.org/articles/intersectors
HitInfo triangleIntersection(Ray ray, vec3 v0, vec3 v1, vec3 v2) {
    vec3 v1v0 = v1 - v0;
    vec3 v2v0 = v2 - v0;
    vec3 rov0 = ray.origin - v0;
    vec3  n = cross( v1v0, v2v0 );

    vec3  q = cross( rov0, ray.dir );
    float d0 = -dot(ray.dir, n);
    float d = 1.f/d0;

    float dst = dot(rov0, n) * d;
    float u = dot(v2v0, q) * d;
    float v = -dot(v1v0, q) * d;
    float w = 1.f - u - v;
    
    HitInfo hit;
    hit.didHit = d0 >= 0.00000001f && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
    hit.hitPoint = ray.origin + ray.dir * dst;
    hit.normal = normalize(n);
    hit.dst = dst;
    return hit;
}

HitInfo calculateIntersections(Ray ray) {
    HitInfo closestHit;
    closestHit.didHit = false;
    closestHit.dst = 999999999;
    RayTracerData traceData = PushConstants.rayTracerParams;

    for (int i = 0; i < traceData.sphereCount; i++) {
        HitInfo hitInfo = sphereIntersection(spheres[i], ray);
        if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {
            closestHit = hitInfo;
        }
    }

    // for (int i = 0; i < traceData.triangleCount; i++) {
    //     uint tris[3] = triangles[i].indices;
    //     HitInfo hitInfo = triangleIntersection(ray, trianglePoints[tris[0]], trianglePoints[tris[1]], trianglePoints[tris[2]]);
    //     if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {
    //         closestHit = hitInfo;
    //     }
    // }

    return closestHit;
}

//from sebastian lague
vec3 getEnvironmentLight(Ray ray) {
    EnvironmentData env = PushConstants.environment;
    float skyGradientT = pow(smoothstep(0, 0.4, -ray.dir.y), 0.35);
    vec3 skyGradient = mix(env.horizonColor, env.zenithColor, skyGradientT);
    float sun = pow(max(0, dot(ray.dir, -PushConstants.lightDir)), env.sunFocus) * env.sunIntensity;

    float groundToSkyT = smoothstep(-0.01, 0, -ray.dir.y);
    float sunMask = float(groundToSkyT >= 1);
    return mix(env.groundColor, skyGradient, groundToSkyT) + sun * sunMask;
}

vec3 trace(Ray ray, inout uint state) {
    vec3 incomingLight = vec3(0.f);
    vec3 rayColor = vec3(1.f);
    RayTracerData traceData = PushConstants.rayTracerParams;
    Ray newRay = ray;

    for (int j = 0; j <= traceData.bounceLimit; j++) {
        HitInfo hitInfo = calculateIntersections(newRay);
        if (hitInfo.didHit) {
            Material material = materials[hitInfo.materialIndex];

            vec3 diffuseDir = normalize(hitInfo.normal + randomDirection(state));
            vec3 specularDir = newRay.dir - hitInfo.normal * 2 * dot(newRay.dir, hitInfo.normal);
            newRay.dir = mix(diffuseDir, specularDir, material.reflectance);
            newRay.origin = hitInfo.hitPoint;

            vec3 emitted = material.emissionColor * material.emissionStrength;
            float lightStrength = dot(hitInfo.normal, newRay.dir);
            incomingLight += lightStrength * emitted * rayColor;
            rayColor *= material.albedo;
        } else {
            incomingLight += getEnvironmentLight(newRay) * rayColor;
            break;
        }
    }

    return incomingLight;
}

void main() {
	ivec2 dim = imageSize(outImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    vec4 oldColor = imageLoad(outImage, ivec2(gl_GlobalInvocationID.xy));

    CameraInfo cam = PushConstants.camInfo;

    //from sebastian lague
    float planeHeight = cam.nearPlane * tan(radians(cam.fov * 0.5f)) * 2.f;
    float planeWidth = planeHeight * cam.aspectRatio;

    vec3 bottomLeft = vec3(-planeWidth / 2.f, -planeHeight / 2.f, 0.1f);
    vec3 point = bottomLeft + vec3(planeWidth * uv.x, planeHeight * uv.y, 0.f);
    vec3 dir = normalize(point); 

    Ray ray;
    ray.dir = (cam.cameraRotation * vec4(dir, 1.f)).xyz;
    ray.origin = cam.pos;

    uint lol = PushConstants.frameCount;
    uint startingSeed = uint(random(lol) * 23892183);
    uint state = gl_GlobalInvocationID.y * dim.x + gl_GlobalInvocationID.x + startingSeed;

    RayTracerData traceData = PushConstants.rayTracerParams;

    vec3 outColor = vec3(0.f);
    for (int i = 0; i < traceData.raysPerPixel; i++) {
        outColor += trace(ray, state);
    }
    outColor /= traceData.raysPerPixel;

    float weight = 1.f / (PushConstants.frameCount + 1.f);
    vec3 finalColor = oldColor.rgb * (1 - weight) + outColor * weight;
    finalColor = traceData.progressive ? finalColor : outColor;

    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1.f));
}
// #ifndef rachIT was HERE
// #define rachit WAS here!