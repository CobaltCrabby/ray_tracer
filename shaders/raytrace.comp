#version 450

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct CameraInfo {
    vec3 pos;
    float nearPlane;
    float aspectRatio;
    float fov;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Sphere {
    vec3 position;
    float radius;
};

layout (binding = 0, rgba8) uniform writeonly image2D outImage;

layout (std140, binding = 1) readonly buffer SphereBuffer {
    Sphere spheres[];
};

layout (push_constant) uniform constants {
    CameraInfo camInfo;
    mat4 cameraRotation;
} PushConstants;

bool sphereIntersection(vec3 center, float radius, Ray ray) {
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4 * a * c;
    return discriminant > 0;
}

void main() {
	ivec2 dim = imageSize(outImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    CameraInfo cam = PushConstants.camInfo;

    //from sebastian lague
    float planeHeight = cam.nearPlane * tan(radians(cam.fov * 0.5f)) * 2.f;
    float planeWidth = planeHeight * cam.aspectRatio;

    vec3 bottomLeft = vec3(-planeWidth / 2.f, -planeHeight / 2.f, 0.1f);
    vec3 point = bottomLeft + vec3(planeWidth * uv.x, planeHeight * uv.y, 0.f);
    vec3 dir = normalize(point); 

    Ray ray;
    ray.direction = (PushConstants.cameraRotation * vec4(dir, 1.f)).xyz;
    ray.origin = cam.pos;
    
    bool hit = false;
    for (int i = 0; i < 2; i++) {
        if (!hit) {
            hit = sphereIntersection(spheres[i].position, spheres[i].radius, ray);
        } else {
            break;
        }
    }
    
    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(hit));
}