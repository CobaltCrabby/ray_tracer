#version 450
// Rachit was here :)

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct CameraInfo {
    mat4 cameraRotation;
    vec3 pos;
    float nearPlane;
    float aspectRatio;
    float fov;
};

struct Ray {
    vec3 origin;
    vec3 dir;
    vec3 invDir;
    uvec3 dimSign;
};

//material
struct Material {
    vec3 albedo; //albedo.w = reflectance
    vec3 emissionColor; //emissionColor.w = emissionStrength
    float emissionStrength;
	float reflectance;
    float ior;
    uint albedoIndex;
    uint metalnessIndex;
};

//objects
struct BoundingBox {
    //[0] = min, [1] = max, only use 3 of the vec components bc memory alignment
    vec4[2] bounds; 
};

struct RenderObject {
    mat4 transformMatrix;
    BoundingBox boundingBox;
    uint smoothShade; //0 = off, 1 = on (bool weird on glsl)
    uint triangleStart;
    uint triangleCount;
    uint materialIndex;
};

//shapes
struct Sphere {
    vec3 position;
    float radius;
    uint materialIndex;
};

struct Triangle {
    uint v0;
    uint v1;
    uint v2;
    uint padding;
};

struct TrianglePoint {
    vec4 position;
    vec4 normal;
};

struct HitInfo {
    vec3 hitPoint;
    vec3 normal;
    vec2 uv;
    float dst;
    uint materialIndex;
    bool didHit;
    bool frontFace;
};

//push constants
struct EnvironmentData {
    vec4 horizonColor; //w = sun focus
    vec4 zenithColor; //w = sun intensity
    vec3 groundColor;
    vec4 lightDir; //w = environment on
};

struct RayTracerData {
    bool progressive;
    uint raysPerPixel;
    uint bounceLimit;
    uint sphereCount;
    uint objectCount;
};

layout (binding = 0, rgba8) uniform image2D outImage;

layout (binding = 1, rgba8) uniform readonly image2D TextureBuffer[2];

layout (std140, binding = 2) readonly buffer SphereBuffer {
    Sphere spheres[];
};

layout (std140, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
};

layout (std140, binding = 4) readonly buffer TrianglePositionBuffer {
    TrianglePoint trianglePoints[];
};

layout (std140, binding = 5) readonly buffer TriangleBuffer {
    Triangle triangles[];
};

layout (std140, binding = 6) readonly buffer ObjectBuffer {
    RenderObject objects[];
};

layout (push_constant) uniform constants {
    CameraInfo camInfo;
    EnvironmentData environment;
    RayTracerData rayTracerParams;
    uint frameCount;
} PushConstants;

//https://www.shadertoy.com/view/4ssXzX
float random(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result / 4294967295.f;
}

float randomNormal(inout uint state) {
    float theta = 2 * 3.141592 * random(state);
    float rho = sqrt(-2 * log(random(state)));
    return rho * cos(theta);
}

vec3 randomDirection(inout uint state) {
    vec3 randomDir = vec3(randomNormal(state), randomNormal(state), randomNormal(state));
    randomDir = normalize(randomDir);
    return randomDir;
}

float schlick(float cosine, float refraction_index) {
    float r0 = (1 - refraction_index) / (1 + refraction_index);
    r0 = r0 * r0;
    return r0 + (1 - r0) * pow((1 - cosine), 5);
}

Ray refraction(Ray ray, vec3 normal, float ior, inout uint state) {
    float cosine = dot(-ray.dir, normal);
    float sine =  sqrt(1 - cosine * cosine);
    bool solution = (ior * sine) > 1.f || schlick(cosine, ior) > random(state);
    vec3 dir = solution ? reflect(ray.dir, normal) : refract(ray.dir, normal, ior);
    vec3 origin = ray.origin + normal * 0.0001 * (solution ? 1 : sign(dot(normal, ray.dir)));
    Ray newRay;
    newRay.dir = dir;
    newRay.origin = origin;
    return newRay;
}

HitInfo sphereIntersection(Sphere sphere, Ray ray) {
    HitInfo hitInfo;
    hitInfo.didHit = false;

    vec3 oc = sphere.position - ray.origin;
    float a = dot(ray.dir, ray.dir);
    float b = dot(oc, ray.dir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - a * c;

    if (discriminant >= 0) {
        float sqrtd = sqrt(discriminant);
        float dst = (b - sqrtd) / a;
        hitInfo.frontFace = true;
        if (dst < 0) {
            dst = (b + sqrtd) / a;
            hitInfo.frontFace = false;
            if (dst < 0) {
                return hitInfo;
            }
        }

        hitInfo.didHit = true;
        hitInfo.dst = dst;
        hitInfo.hitPoint = ray.origin + ray.dir * dst;
        hitInfo.normal = normalize(hitInfo.hitPoint - sphere.position) * (hitInfo.frontFace ? 1 : -1);
        hitInfo.materialIndex = sphere.materialIndex;
    }
    return hitInfo;
}

//https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
HitInfo triangleIntersection(Ray ray, TrianglePoint v0, TrianglePoint v1, TrianglePoint v2, bool smoothShade) {
    vec3 v1v2 = v1.position.xyz - v2.position.xyz;
    vec3 v1v0 = v1.position.xyz - v0.position.xyz;
    vec3 v2v0 = v2.position.xyz - v0.position.xyz;
    vec3 rov0 = ray.origin - v0.position.xyz;
    vec3 n = cross( v1v0, v2v0 );

    vec3  q = cross( rov0, ray.dir );
    float d0 = -dot(ray.dir, n);
    float d = 1.f/d0;

    float dst = dot(rov0, n) * d;
    float u = dot(v2v0, q) * d;
    float v = -dot(v1v0, q) * d;
    float w = 1.f - u - v;
    
    HitInfo hit;
    hit.didHit = d0 >= 0.00000001f && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
    hit.hitPoint = ray.origin + ray.dir * dst;
    hit.dst = dst;

    //area of a triangle = |AB x AC|/2 where AB and AC is the edge vectors. use for barycentric calcs
    float area = length(cross(v1v0, v2v0)) / 2.f;
    float pbc = length(cross(hit.hitPoint - v2.position.xyz, v1v2)) / 2.f;
    float apc = length(cross(hit.hitPoint - v0.position.xyz, v2v0)) / 2.f;
    float abp = length(cross(hit.hitPoint - v0.position.xyz, v1v0)) / 2.f;

    vec3 barycentric = vec3(pbc, apc, abp) / area;
    vec2 v0uv = vec2(v0.position.w, v0.normal.w);
    vec2 v1uv = vec2(v1.position.w, v1.normal.w);
    vec2 v2uv = vec2(v2.position.w, v2.normal.w);
    hit.uv = barycentric.x * v0uv + barycentric.y * v1uv + barycentric.z * v2uv;

    hit.normal = smoothShade ? barycentric.x * v0.normal.xyz + barycentric.y * v1.normal.xyz + barycentric.z * v2.normal.xyz : normalize(n);
    return hit;
}

bool boxIntersection(BoundingBox box, Ray ray) {
    float tmin, tmax, tymin, tymax, tzmin, tzmax;
    tmin = (box.bounds[ray.dimSign.x].x - ray.origin.x) * ray.invDir.x;
    tmax = (box.bounds[1 - ray.dimSign.x].x - ray.origin.x) * ray.invDir.x;
    tymin = (box.bounds[ray.dimSign.y].y - ray.origin.y) * ray.invDir.y;
    tymax = (box.bounds[1 - ray.dimSign.y].y - ray.origin.y) * ray.invDir.y;
    if ((tmin > tymax) || (tymin > tmax))
        return false;
    if (tymin > tmin)
        tmin = tymin;
    if (tymax < tmax)
        tmax = tymax;
    tzmin = (box.bounds[ray.dimSign.z].z - ray.origin.z) * ray.invDir.z;
    tzmax = (box.bounds[1-ray.dimSign.z].z - ray.origin.z) * ray.invDir.z;
    if ((tmin > tzmax) || (tzmin > tmax))
        return false;
    if (tzmin > tmin)
        tmin = tzmin;
    if (tzmax < tmax)
        tmax = tzmax;
    return ((tmin < 9999) && (tmax > 0));
}

HitInfo calculateIntersections(Ray ray) {
    HitInfo closestHit;
    closestHit.didHit = false;
    closestHit.dst = 999999999;
    RayTracerData traceData = PushConstants.rayTracerParams;

    for (int i = 0; i < traceData.sphereCount; i++) {
        HitInfo hitInfo = sphereIntersection(spheres[i], ray);
        if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {
            closestHit = hitInfo;
        }
    }

    for (int i = 0; i < traceData.objectCount; i++) {
        RenderObject object = objects[i];
        Ray transformRay;
        transformRay.dir = (inverse(object.transformMatrix) * vec4(ray.dir, 0.f)).xyz;
        transformRay.origin = (inverse(object.transformMatrix) * vec4(ray.origin, 1.f)).xyz;
        transformRay.invDir = 1 / transformRay.dir;

        for (int j = 0; j < 3; j++) {
            transformRay.dimSign[j] = uint(transformRay.invDir[j] < 0);
        }

        if (!boxIntersection(object.boundingBox, transformRay)) continue;

        for (uint j = object.triangleStart; j < object.triangleStart + object.triangleCount; j++) {
            Triangle tri = triangles[j];
            HitInfo hitInfo = triangleIntersection(transformRay, trianglePoints[tri.v0], trianglePoints[tri.v1], trianglePoints[tri.v2], bool(object.smoothShade));
            hitInfo.materialIndex = object.materialIndex;

            if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {
                closestHit = hitInfo;
                closestHit.normal = normalize((object.transformMatrix * vec4(closestHit.normal, 0.f))).xyz;
                closestHit.hitPoint = (object.transformMatrix * vec4(closestHit.hitPoint, 1.f)).xyz;
            }
        }
    }

    return closestHit;
}

//from sebastian lague
vec3 getEnvironmentLight(Ray ray) {
    EnvironmentData env = PushConstants.environment;
    float skyGradientT = pow(smoothstep(0, 0.4, -ray.dir.y), 0.35);
    vec3 skyGradient = mix(env.horizonColor.xyz, env.zenithColor.xyz, skyGradientT);
    float sun = pow(max(0, dot(ray.dir, -env.lightDir.rgb)), env.horizonColor.w) * env.zenithColor.w;

    float groundToSkyT = smoothstep(-0.01, 0, -ray.dir.y);
    float sunMask = float(groundToSkyT >= 1);
    return mix(env.groundColor, skyGradient, groundToSkyT) + sun * sunMask;
}

vec3 trace(Ray ray, inout uint state) {
    vec3 incomingLight = vec3(0.f);
    vec3 rayColor = vec3(1.f);
    RayTracerData traceData = PushConstants.rayTracerParams;
    Ray newRay = ray;
    float currentIor = -1.f;

    for (int j = 0; j <= traceData.bounceLimit; j++) {
        HitInfo hitInfo = calculateIntersections(newRay);
        if (hitInfo.didHit) {  
            Material material = materials[hitInfo.materialIndex];
            float reflectance = material.reflectance;
            if (material.metalnessIndex != -1) {
                ivec2 size = imageSize(TextureBuffer[material.metalnessIndex]);
                reflectance = imageLoad(TextureBuffer[material.metalnessIndex], ivec2(vec2(hitInfo.uv.x, 1 - hitInfo.uv.y) * size)).r;
            }

            newRay.origin = hitInfo.hitPoint;
            if (material.ior != -1.f) {
                newRay = refraction(newRay, hitInfo.normal, hitInfo.frontFace ? 1.f / material.ior : material.ior, state);
            } else {
                vec3 diffuseDir = normalize(hitInfo.normal + randomDirection(state));
                vec3 specularDir = reflect(newRay.dir, hitInfo.normal);
                newRay.dir = mix(diffuseDir, specularDir, reflectance);
                newRay.origin += hitInfo.normal * 0.0001;
            }
            currentIor = material.ior;

            vec3 emitted = material.emissionColor * material.emissionStrength;
            float lightStrength = dot(hitInfo.normal, newRay.dir);
            incomingLight += lightStrength * emitted * rayColor;

            if (material.albedoIndex != -1) {
                ivec2 size = imageSize(TextureBuffer[material.albedoIndex]);
                vec3 albedo = imageLoad(TextureBuffer[material.albedoIndex], ivec2(vec2(hitInfo.uv.x, 1 - hitInfo.uv.y) * size)).rgb;
                rayColor *= albedo;
                continue;
            } 
            rayColor *= material.albedo.rgb;
        } else {
            incomingLight += (PushConstants.environment.lightDir.w == 1.f ? getEnvironmentLight(newRay) : vec3(0.f)) * rayColor;
            break;
        }
    }

    return incomingLight;
}

void main() {
	ivec2 dim = imageSize(outImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    vec4 oldColor = imageLoad(outImage, ivec2(gl_GlobalInvocationID.xy));

    CameraInfo cam = PushConstants.camInfo;

    //from sebastian lague
    float planeHeight = cam.nearPlane * tan(radians(cam.fov * 0.5f)) * 2.f;
    float planeWidth = planeHeight * cam.aspectRatio;

    vec3 bottomLeft = vec3(-planeWidth / 2.f, -planeHeight / 2.f, 0.1f);
    vec3 point = bottomLeft + vec3(planeWidth * uv.x, planeHeight * uv.y, 0.f);
    vec3 dir = normalize(point); 

    Ray ray;
    ray.dir = (cam.cameraRotation * vec4(dir, 1.f)).xyz;
    ray.origin = cam.pos;
    ray.invDir = 1.f / ray.dir;
    for (int i = 0; i < 3; i++) {
        ray.dimSign[i] = uint(ray.invDir[i] < 0);
    }

    uint lol = PushConstants.frameCount;
    uint startingSeed = uint(random(lol) * 23892183);
    uint state = gl_GlobalInvocationID.y * dim.x + gl_GlobalInvocationID.x + startingSeed;

    RayTracerData traceData = PushConstants.rayTracerParams;

    vec3 outColor = vec3(0.f);
    for (int i = 0; i < traceData.raysPerPixel; i++) {
        outColor += trace(ray, state);
    }
    outColor /= traceData.raysPerPixel;

    float weight = 1.f / (PushConstants.frameCount + 1.f);
    vec3 finalColor = oldColor.rgb * (1 - weight) + outColor * weight;
    finalColor = traceData.progressive ? finalColor : outColor;
    if (any(isnan(finalColor)) || any(isinf(finalColor))) {
        finalColor = vec3(1.f, 0.f, 1.f);
    }

    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1.f));//vec4(finalColor, 1.f));
}
// #ifndef rachIT was HERE
// #define rachit WAS here!